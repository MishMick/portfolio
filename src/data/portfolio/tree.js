/**
 * A class that implements the queue data type.
 */
class Queue {
  /**
   * Create a new object of class Queue.
   *
   * @constructor
   * @constructs {Queue}
   */
  constructor () {
    this.oldestIndex = 1
    this.newestIndex = 1
    this.storage = {}
  }

  size () {
    return this.newestIndex - this.oldestIndex
  }

  enqueue (data) {
    this.storage[this.newestIndex] = data
    this.newestIndex++
  }

  dequeue () {
    let oldestIndex = this.oldestIndex
    let newestIndex = this.newestIndex
    let deletedData

    if (oldestIndex !== newestIndex) {
      deletedData = this.storage[oldestIndex]
      delete this.storage[oldestIndex]
      this.oldestIndex++
      return deletedData
    }
  }
}

/**
 * A class that implements one node in the tree data type.
 *
 * Here each node refers to an entity on a given file system which may be a file
 * or a folder.
 */
class Node {
  /**
   * Create a new object of class Node.
   *
   * @constructor
   * @param {string} name - the name of the node
   * @param {string} alternativeName - an alias that refers to this node
   * @param {string} type - the type of node this is in the filesystem
   * @constructs {Node}
   */
  constructor (name, alternativeName, type) {
    this.name = name
    if (alternativeName === undefined) {
      this.alternativeName = name
    } else {
      this.alternativeName = alternativeName
    }
    this.type = type

    this.parent = null
    this.children = []
  }
}

/**
 * A class that implements the tree data type.
 *
 * Here the tree refers to the directory structure on a given file system.
 */
class Tree {
  /**
   * Create a new object of class Tree.
   *
   * @constructor
   * @param root {Node} - the root node of the tree
   * @constructs {Tree}
   */
  constructor (root) {
    root.parent = root
    this.root = root
  }

  traverseDepthFirst (callback) {
    (function recurse (currentNode) {
      currentNode.children.forEach(child => {
        recurse(child)
      })
      callback(currentNode)
    })(this.root)
  }

  traverseBreadthFirst (callback) {
    let queue = new Queue()
    queue.enqueue(this.root)
    let currentTree = queue.dequeue()
    while (currentTree) {
      currentTree.children.forEach(child => {
        queue.enqueue(child)
      })
      callback(currentTree)
      currentTree = queue.dequeue()
    }
  }

  contains (callback, traversal) {
    traversal.call(this, callback)
  }

  add (node, parentName, traversal) {
    let parent = null
    let callback = function (node) {
      if (node.name === parentName) {
        parent = node
      }
    }
    this.contains(callback, traversal)
    if (parent) {
      parent.children.push(node)
      node.parent = parent
    } else {
      console.log(`Error occurred when adding ${node.name} to ${parentName}`)
    }
  }
}

/**
 * Create an object of class Tree using the JSON tree object.
 *
 * @param {Object} basicTree - the JSON object to convert to a tree
 * @return {Tree} the Tree object generated by traversing basicTree
 */
function generateTree (basicTree) {
  let node = new Node(
    basicTree.name,
    basicTree.alternativeName,
    basicTree.type
  )
  let tree = new Tree(node)

  populateTree(tree, basicTree)

  return tree
}

/**
 * Populate the object of class Tree by recursively traversing the JSON tree.
 *
 * @param {Tree} tree - the Tree object being populated
 * @param {Object} basicNode - the current JSON node to traverse
 */
function populateTree (tree, basicNode) {
  let basicChildren = basicNode.children

  for (let i = 0; i < basicChildren.length; i++) {
    let basicChild = basicChildren[i]
    let childNode = new Node(
      basicChild.name,
      basicChild.alternativeName,
      basicChild.type
    )

    tree.add(childNode, basicNode.name, tree.traverseBreadthFirst)

    if (basicChild.type === 'folder') {
      populateTree(tree, basicChild)
    }
  }
}

export {
  generateTree
}
